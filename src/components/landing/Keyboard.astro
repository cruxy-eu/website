---
interface Props {
  keys: Key[];
}
interface Key{
  key: string;
  href: string;
}
const { keys }: Props = Astro.props;
keys.reverse();
---
<div class="keyboard flex flex-wrap items-center justify-center flex-row-reverse relative">
{
  keys.map((key, i) => (
    <div
      class="key-container">
          <div class:list={[
            `z-${i+1}`,
            "key p-4 text-4xl w-40 bg-muted-background border-l-12 border-b-12 border-t-2 border-r-2 border-l-neutral-600 border-b-neutral-800 border-t-neutral-400 border-r-neutral-400 font-mono hover:cursor-pointer transition-all rounded-xl -m-0.5 text-center",
            "transform skew-x-10"
          ]}>
          <a href={key.href}>{key.key}</a>
      </div>
    </div>
  ))
}
</div>
<style>

    .key {
        box-shadow: 4px 4px 0px 0px rgba(0, 0, 0, 0.2);
        transition: all 0.2s ease-in-out;
    }

    .key:hover {
        transform: translate(-5px, 5px) skewX(10deg);
    }


    @media (prefers-reduced-motion: no-preference) {
        .key-container {
            opacity: 0;
            transform: translate(20px, -20px) skewX(10deg);
        }

        .key-container.animate-in {
            opacity: 1;
            transform: translate(0, 0) skewX(10deg);
            transition:
                opacity 0.5s ease-out,
                transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
    }


    @prefers-reduced-motion (reduce) {
        .key-container, .key-container.animate-in, .key:hover {
            opacity: 1 !important;
            transition: none !important;
            transform: none !important;
        }
    }

</style>
<script>
const observerOptions = {
  threshold: 0.1,
  rootMargin: '0px 0px -50px 0px'
};

const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      // Animate children with stagger
      const keys = entry.target.querySelectorAll('.key-container');
      const reversedKeys: Element[] = Array.from(keys).reverse();
      reversedKeys.forEach((key, index) => {
        setTimeout(() => {
          key.classList.add('animate-in');
        }, index * 100); // 100ms delay between each key
      });

      observer.unobserve(entry.target);
    }
  });
}, observerOptions);

// Observe the container
document.querySelectorAll('.keyboard').forEach(el => {
  observer.observe(el);
});
</script>
